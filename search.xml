<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>论语之学而</title>
    <url>/2019/11/30/%E8%AE%BA%E8%AF%AD%E4%B9%8B%E5%AD%A6%E8%80%8C/</url>
    <content><![CDATA[<center><font size="8">学而</font></center>

 <a id="more"></a> 
<p>　　子曰：“学而时习之，不亦说乎？有朋自远方来，不亦乐乎？人不知而不愠，不亦君子乎？”</p>
<p>　　有子曰：“其为人也孝弟，而好犯上者，鲜矣；不好犯上而好作乱者，未之有也。君子务本，本立而道生。孝弟也者，其为仁之本与！”</p>
<p>　　子曰：“巧言令色，鲜矣仁！”</p>
<p>　　曾子曰：“吾日三省吾身：为人谋而不忠乎？与朋友交而不信乎？传不习乎？”</p>
<p>　　子曰：“道千乘之国，敬事而信，节用而爱人，使民以时。”</p>
<p>　　子曰：“弟子入则孝，出则弟，谨而信，泛爱众，而亲仁，行有余力，则以学文。”</p>
<p>　　子夏曰：“贤贤易色；事父母，能竭其力；事君，能致其身；与朋友交，言而有信。虽曰未学，吾必谓之学矣。”</p>
<p>　　子曰：“君子不重则不威，学则不固。主忠信，无友不如己者，过，则勿惮改。”</p>
<p>　　曾子曰：“慎终追远，民德归厚矣。”</p>
<p>　　子禽问于子贡曰：“夫子至于是邦也，必闻其政，求之与，抑与之与？”子贡曰：“夫子温、良、恭、俭、让以得之。夫子之求之也，其诸异乎人之求之与？”</p>
<p>　　子曰：“父在，观其志；父没，观其行；三年无改于父之道，可谓孝矣。”</p>
<p>　　有子曰：“礼之用，和为贵。先王之道，斯为美。小大由之。有所不行。知和而和，不以礼节之，亦不可行也。”</p>
<p>　　有子曰：“信近于义，言可复也。恭近于礼，远耻辱也。因不失其亲，亦可宗也。”</p>
<p>　　子曰：“君子食无求饱，居无求安，敏于事而慎于言，就有道而正焉。可谓好学也已。”</p>
<p>　　子贡曰：“贫而无谄，富而无骄，何如？”子曰：“可也。未若贫而乐道，富而好礼者也。”子贡曰：“《诗》云：‘如切如磋，如琢如磨’，其斯之谓与？”子曰：“赐也，始可与言《诗》已矣，告诸往而知来者。”</p>
<p>　　子曰：“不患人之不己知，患不知人也。”</p>
]]></content>
      <tags>
        <tag>古典</tag>
      </tags>
  </entry>
  <entry>
    <title>如何阅读一本书</title>
    <url>/2019/11/29/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>这是我在《如何阅读一本书》中得来的一点点收获，记录在这里。</p>
<p>告诉我以后在阅读的时候如何去做。</p>
 <a id="more"></a> 
<h1 id="四个问题"><a href="#四个问题" class="headerlink" title="四个问题"></a>四个问题</h1><p>（1） 整 体 来 说， 这 本 书 到 底 在 谈 些 什 么？ 你 一 定 要 想 办 法 找 出 这 本 书 的 主 题， 作 者 如 何 依 次 发 展 这 个 主 题， 如 何 逐 步 从 核 心 主 题 分 解 出从 属 的 关 键 议 题 来。 </p>
<p>（2） 作 者 细 部 说 了 什 么， 怎 么 说 的？ 你 一 定 要 想 办 法 找 出 主 要 的 想 法、 声 明 与 论 点。 这 些 组 合 成 作 者 想 要 传 达 的 特 殊 讯 息。 </p>
<p>（3） 这 本 书 说 得 有 道 理 吗？ 是 全 部 有 道 理， 还 是 部 分 有 道 理？ 除 非 你 能 回 答 前 两 个 问 题， 否 则 你 没 法 回 答 这 个 问 题。 在 你 判 断 这 本 书 是 否 有 道 理 之 前， 你 必 须 先 了 解 整 本 书 在 说 些 什 么 才 行。 然 而， 等 你 了 解 了 一 本 书， 如 果 你 又 读 得 很 认 真 的 话， 你 会 觉 得 有 责 任 为 这 本 书 做 个 自 己 的 判 断。 光 是 知 道 作 者 的 想 法 是 不 够 的。</p>
<p>（4） 这 本 书 跟 你 有 什 么 关 系？ 如 果 这 本 书 给 了 你 一 些 资 讯， 你 一 定 要 问 问 这 些 资 讯 有 什 么 意 义。 为 什 么 这 位 作 者 会 认 为 知 道 这 件 事 很 重 要？ 你 真 的 有 必 要 去 了 解 吗？ 如 果 这 本 书 不 只 提 供 了 资 讯， 还 启 发 了 你， 就 更 有 必 要 找 出 其 他 相 关 的、 更 深 的 含 意 或 建 议， 以 获 得 更 多 的 启 示。</p>
<h1 id="分析阅读的几点规则"><a href="#分析阅读的几点规则" class="headerlink" title="分析阅读的几点规则"></a>分析阅读的几点规则</h1><p>（1） 依 照 书 的 种 类 与 主 题 来 分 类。 </p>
<p>（2） 使 用 最 简 短 的 文 字 说 明 整 本 书 在 谈 些 什 么。</p>
<p>（3） 将 主 要 部 分 按 顺 序 与 关 联 性 列 举 出 来。 将 全 书 的 大 纲 列 举 出 来， 并 将 各 个 部 分 的 大 纲 也 列 出 来。 </p>
<p>（4） 确 定 作 者 想 要 解 决 的 问 题。</p>
<p>（5） 诠 释 作 者 的 关 键 字， 与 他 达 成 共 识。 </p>
<p>（6） 由 最 重 要 的 句 子 中， 抓 住 作 者 的 重 要 主 旨。 </p>
<p>（7） 知 道 作 者 的 论 述 是 什 么， 从 内 容 中 找 出 相 关 的 句 子， 再 重 新 架 构 出 来。 </p>
<p>（8） 确 定 作 者 已 经 解 决 了 哪 些 问 题， 还 有 哪 些 是 没 解 决 的。 再 判 断 哪 些 是 作 者 知 道 他 没 解 决 的 问 题。</p>
<p>（9） 除 非 你 已 经 完 成 大 纲 架 构， 也 能 诠 释 整 本 书 了， 否 则 不 要 轻 易 批 评。（ 在 你 说 出：“ 我 读 懂 了!” 之 前， 不 要 说 你 同 意、 不 同 意 或 暂 缓 评 论。） </p>
<p>（10） 不 要 争 强 好 胜， 非 辩 到 底 不 可。</p>
<p>（11） 在 说 出 评 论 之 前， 你 要 能 证 明 自 己 区 别 得 出 真 正 的 知 识 与 个 人 观 点 的 不 同。</p>
<p>（12） 证 明 作 者 的 知 识 不 足。 </p>
<p>（13） 证 明 作 者 的 知 识 错 误。</p>
<p>（14） 证 明 作 者 不 合 逻 辑。</p>
<p>（15） 证 明 作 者 的 分 析 与 理 由 是 不 完 整 的。</p>
<h1 id="主动地阅读"><a href="#主动地阅读" class="headerlink" title="主动地阅读"></a>主动地阅读</h1><p>在阅读的时候，不能是昏昏欲睡的，决不能变成那种，我看完了全文，但是我不知道它说了些什么。</p>
<p>要能回答这四个问题，别人问的时候，要能说出自己最真切的体会。</p>
<p>无论如何，要当一个主动的读者，不能当一个僵硬、死记硬背、读完就忘的读者。</p>
]]></content>
      <tags>
        <tag>阅读记录</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode第5题</title>
    <url>/2019/11/29/leetcode%E7%AC%AC5%E9%A2%98/</url>
    <content><![CDATA[<h1 id="leetcode第5题"><a href="#leetcode第5题" class="headerlink" title="leetcode第5题"></a>leetcode第5题</h1> <a id="more"></a> 
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p> 给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。 </p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>示例1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure>
<p>示例2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这道题有好几种思路，但是我只能想到暴力破解。。。。</p>
<p>这里就在每种解法下面谈一谈思路吧。</p>
<h1 id="解法1–暴力破解"><a href="#解法1–暴力破解" class="headerlink" title="解法1–暴力破解"></a>解法1–暴力破解</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self,s)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i]!=s[len(s)-i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        maxLength=<span class="number">-1</span></span><br><span class="line">        res=<span class="string">""</span></span><br><span class="line">        tmp=<span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(j,len(s)):</span><br><span class="line"></span><br><span class="line">                tmp=s[j:k+<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> self.isPalindrome(tmp):</span><br><span class="line">                    <span class="keyword">if</span> len(tmp)&gt;maxLength:</span><br><span class="line">                        maxLength=len(tmp)</span><br><span class="line">                        res=tmp</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>暴力破解没啥好聊的，就是三重循环。第一二重选出字符串，在第三重判断是不是回文字符串。</p>
<p>结果就是超时，聊不动。</p>
<h1 id="解法2–最长公共子串"><a href="#解法2–最长公共子串" class="headerlink" title="解法2–最长公共子串"></a>解法2–最长公共子串</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="解法3–动态规划"><a href="#解法3–动态规划" class="headerlink" title="解法3–动态规划"></a>解法3–动态规划</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) &lt; <span class="number">2</span> <span class="keyword">or</span> s == s[::<span class="number">-1</span>]:  <span class="comment"># 如果长度为0或1，或者本身就是回文，返回s本身</span></span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        </span><br><span class="line">        max_len = <span class="number">1</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(s)):   <span class="comment">#将s[i]作为回文子串的最右边字符算</span></span><br><span class="line">            even = s[i - max_len : i + <span class="number">1</span>]   <span class="comment"># 从 i-max_len 到 i ，共 max_len+1 个，初始为2</span></span><br><span class="line">            odd = s[i - max_len - <span class="number">1</span> : i + <span class="number">1</span>]    <span class="comment"># 从 i-max_len-1 到 i ，共 max_len+2 个，初始为3</span></span><br><span class="line">            <span class="keyword">if</span> i - max_len - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> odd == odd[::<span class="number">-1</span>]:   <span class="comment"># 因为odd = s[i-max_len-1 : i+1]，所以要i-max_len-1非负odd才有意义</span></span><br><span class="line">                start = i - max_len - <span class="number">1</span></span><br><span class="line">                max_len += <span class="number">2</span>    <span class="comment"># 为什么加2，因为odd的长度是max_len+2</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> i - max_len &gt;= <span class="number">0</span> <span class="keyword">and</span> even == even[::<span class="number">-1</span>]: <span class="comment"># 同理需要i-max_len非负even才有意义，</span></span><br><span class="line">                start = i - max_len</span><br><span class="line">                max_len +=  <span class="number">1</span>   <span class="comment"># 同理，even的长度是max_len+1</span></span><br><span class="line">        <span class="keyword">return</span> s[start : start + max_len]</span><br></pre></td></tr></table></figure>
<h1 id="解法4–扩展中心"><a href="#解法4–扩展中心" class="headerlink" title="解法4–扩展中心"></a>解法4–扩展中心</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expandCenter</span><span class="params">(self,s,i,j)</span>:</span></span><br><span class="line">        L=i</span><br><span class="line">        R=j</span><br><span class="line">        <span class="keyword">while</span> L&gt;=<span class="number">0</span> <span class="keyword">and</span> R&lt;len(s) <span class="keyword">and</span> s[L]==s[R]:</span><br><span class="line">            L=L<span class="number">-1</span></span><br><span class="line">            R=R+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> R-L<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> len(s)&lt;<span class="number">1</span> <span class="keyword">or</span> s==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>    </span><br><span class="line">        start=<span class="number">0</span></span><br><span class="line">        end=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            len1=self.expandCenter(s,i,i)</span><br><span class="line">            len2=self.expandCenter(s,i,i+<span class="number">1</span>)</span><br><span class="line">            length=max(len1,len2)</span><br><span class="line">            <span class="keyword">if</span> (length&gt;(end-start)):</span><br><span class="line">                start=i-(length<span class="number">-1</span>)//<span class="number">2</span></span><br><span class="line">                end=i+length//<span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> s[start:end+<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>扩展中心法就是从某个点出发，找这个点符合的最大回文串。</p>
<p>比较全部点的最大回文串，找出最大的那个，就是结果。</p>
<p>这里的长度折腾了我好久，是R-L-1。这里的减1是去除一开始两个数带进来的偏差。</p>
<h1 id="解法5–manacher’s-algorithm"><a href="#解法5–manacher’s-algorithm" class="headerlink" title="解法5–manacher’s algorithm"></a>解法5–manacher’s algorithm</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        s = <span class="string">"!#"</span> + <span class="string">"#"</span>.join(s) + <span class="string">"#?"</span></span><br><span class="line">        center = <span class="number">0</span> <span class="comment">#最长回文子串中心点</span></span><br><span class="line">        max_right = <span class="number">0</span> <span class="comment">#最长回文子串最远位置</span></span><br><span class="line">        max_s = <span class="number">0</span> <span class="comment">#最长回文子串中心点所在地的位置</span></span><br><span class="line"> </span><br><span class="line">        p = [<span class="number">0</span>] * (len(s)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> i &lt; max_right:</span><br><span class="line">                p[i] = min(max_right-i, p[<span class="number">2</span>*center-i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p[i] = <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">            <span class="keyword">while</span> i-p[i]&gt;<span class="number">0</span> <span class="keyword">and</span> i+p[i]&lt;len(s) <span class="keyword">and</span> s[i-p[i]]==s[i+p[i]]:</span><br><span class="line">                p[i]+=<span class="number">1</span></span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> i+p[i] &gt; max_right:</span><br><span class="line">                max_right = i+p[i]</span><br><span class="line">                center = i</span><br><span class="line">            max_s = max(max_s, p[i])</span><br><span class="line">        </span><br><span class="line">        s=s[p.index(max_s)-(max_s<span class="number">-1</span>): p.index(max_s)+(max_s<span class="number">-1</span>)]</span><br><span class="line">        s=s.replace(<span class="string">'#'</span>,<span class="string">''</span>) </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读记录之批判性思维工具</title>
    <url>/2019/11/28/%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95%E4%B9%8B%E3%80%8A%E6%89%B9%E5%88%A4%E6%80%A7%E6%80%9D%E7%BB%B4%E5%B7%A5%E5%85%B7%E3%80%8B/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>当初为什么要借这本《批判性思维工具》？</p>
<p>是因为我觉得，我一直是一个不爱动脑子的人。不管面对什么情况，提不出问题，很容易就僵硬在原点。</p>
<p>读这本书，是希望能够给我带来一点点的改变。因为我已经阅读过很多思考的书了，但是脑子都是不太愿意去思考，在很多书看过之后，自然而然地就忘了。</p>
<p>一直处于这种后悔和想要努力的状态中，顺便就找了这本书来看。</p>
<p>现在看来，还是有点收获的。</p>
<p>阅读，还是要思考，要明白一本书到底说的是什么？</p>
<p>这本书也是第一次带给我不一样的感觉：没有一字一句看过去，但是我觉得我应该抓住了精髓。</p>
 <a id="more"></a> 
<h1 id="思维、感受和需求"><a href="#思维、感受和需求" class="headerlink" title="思维、感受和需求"></a>思维、感受和需求</h1><p>我们的大脑是很神奇的东西，它有三个基本功能：思维、感受和需求。</p>
<p>思维是我们感知世界的工具，它帮助我们了解世界，弄明白发生了什么？</p>
<p>而感受告诉我们做的怎么样，决定我们的心情和精神状态，是积极阳光，还是失落沮丧。</p>
<p>需求则给与我们奋斗的力量和追求事物的渴望，也告诉我们哪些东西不知道取追寻，不要自寻烦恼。</p>
<p>思维、感受、需求三者相互联系，思维在这里面扮演了一个关键性的角色，它告诉我们世界怎么样，我们应该朝哪个方向前进。</p>
<p>有一个最简单的例子：两个学生在练习写作。其中一个认为写的好就是天生拥有的，自己肯定不行；另外一个则认为写作是可以慢慢训练的，现在虽然自己很弱，但是一点一滴积累，自己肯定能赶超那些现在很强的人。结果是很明显的，前者会很快放弃，并且再也不去碰写作；后者会持续的学习、练习，坚持不懈地进行，能成为常说的“天生作家”。</p>
<p>显然，不同的思维会带给我们完全不一样的感受，并影响了我们的精神状态。</p>
<p>而成为一个批判性思考者，能改变我们错误、有偏见的认知，带给我们完全不一样的体验。</p>
<h1 id="批判性思维"><a href="#批判性思维" class="headerlink" title="批判性思维"></a>批判性思维</h1><p>首先来介绍什么是批判性思维。</p>
<p>批判性思维是建立在良好判断的基础上，使用恰当的评估标准对事物的真实价值进行判断和思考。</p>
<p>作为一个批判性思考者，最直观的表现就是认识到自己的思维有问题，不断挑战自己的思维，并用更加合理的来替代；也明白这个过程是不断进行的，能够分析自己的思维，合理决策，而不是无意识地跟着走。</p>
<h1 id="如何去做"><a href="#如何去做" class="headerlink" title="如何去做"></a>如何去做</h1><p>在知道怎么做之前，先来了解思维过程和思维标准。他们是贯穿思考过程始终的，就和吃饭要拿起筷子、打篮球得了解基本规则一样。</p>
<p>思维过程：</p>
<ul>
<li>我的基本目的是什么</li>
<li>关于这个问题，我的观点是什么</li>
<li>我推理的假设是什么</li>
<li>我推理带来的意义是什么</li>
<li>回答问题时，我需要哪些信息</li>
<li>我得到的推论和结论是什么</li>
<li>这个问题中最基本的概念是什么</li>
<li>我想要回答的关键问题是什么</li>
</ul>
<p>思维标准：</p>
<ul>
<li>清晰性</li>
<li>准确性</li>
<li>精确性</li>
<li>相关性</li>
<li>深度</li>
<li>广度</li>
<li>逻辑性</li>
<li>重要性</li>
<li>公正性</li>
</ul>
<p>使用思维标准来评估我们的思维过程，这个过程是不可或缺的。我们要意识到评估失败带给我们的负面影响，悲伤、沮丧、压抑的心情，触犯法律的行为等等。</p>
<p>知晓了这两项，可以提出一个思考计划。我们要认识到思考改变不是一个一蹴而就的过程，它需要每天不间断地练习，不断地练习，才会有丰厚的收获。以下是计划：</p>
<ul>
<li>利用“浪费”的时间</li>
<li>每天解决一个问题</li>
<li>将思维标准内化</li>
<li>坚持做思维日记</li>
<li>练习思维策略</li>
<li>关注自己的情绪、重新塑造性格、改变自我</li>
</ul>
<p>这些只是泛泛而谈，接下来要谈的是如何具体进行。</p>
<h1 id="具体进行"><a href="#具体进行" class="headerlink" title="具体进行"></a>具体进行</h1><p>首先要学会提问，做一个苏格拉底式的提问者。</p>
<ul>
<li>尽最大可能去理解所说或所信事物的根本基础。</li>
<li>找出观点间的相互联系，深入思考。</li>
<li>用不断完善的需求对待所有观点</li>
<li>认识到所有的问题都以先前的问题为基础。</li>
</ul>
<p>其次，要明白思维和内容是相互联系的，要明白对应的内容，是要培养相应的思维方式。</p>
<p>接下来是向优秀的思维者学习，要能够掌控自己的学习过程，并且制定学习计划，严格执行计划。在这个过程中，必须知道自己想要回答哪些问题、得到哪些信息、学习哪些概念、掌握哪些观点。这个过程，还得不断地利用特征进行评价，不断地改进自己的表现。</p>
<p>最后，利用这样的思维进行决策和解决问题，避免掉自我中心化和非理性的负面影响，朝着正确的轨道前进。</p>
<h1 id="成为一名高级的思考者"><a href="#成为一名高级的思考者" class="headerlink" title="成为一名高级的思考者"></a>成为一名高级的思考者</h1><p>我们不太可能成为一名完善的思考者，但是成为一位高级批判性思考者是完全有可能的。</p>
<p>我们要追求这样的心理品质：</p>
<p>能意识到自己思维的运作</p>
<ul>
<li>意识到自己的思维和行动模式</li>
<li>深思熟虑地做出改变</li>
<li>赞同自己的内在逻辑</li>
</ul>
<p>高度整合信息</p>
<ul>
<li>灵活地运用不同的知识</li>
<li>洞察基本概念和原则，组织大量信息</li>
</ul>
<p>合乎理性、有逻辑</p>
<ul>
<li>经常分析事物的逻辑</li>
<li>综合分析多个理由和证据</li>
<li>能在多重框架下进行推理</li>
<li>通过思考增加理解和洞察力</li>
</ul>
<p>目光长远</p>
<ul>
<li>采取长远的观点</li>
<li>规划自己的发展</li>
<li>关注最终的价值</li>
</ul>
<p>深刻、能够自我修正的</p>
<ul>
<li>对自己的基本信仰和价值观有深刻的见解</li>
<li>了解思维、感受、行动背后的深刻动机</li>
<li>应用思维标准评价自己的思维、感受和行为</li>
<li>发现批评自己的自我中心和社会中心</li>
<li>能够调整自己的生活模式、习惯和行为</li>
</ul>
<p>要朝着一个高级思考者前进呀！</p>
]]></content>
      <tags>
        <tag>阅读记录</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔之2019-11-28</title>
    <url>/2019/11/28/%E9%9A%8F%E7%AC%94%E4%B9%8B2019-11-28/</url>
    <content><![CDATA[<p> 在写这个之前，我又没有控制住自己去看直播了，好大的讽刺呀！！！</p>
<p>今天晚上，本应该是五点半开始，七点半结束，然后还有时间在科研，但是现在的话，就变成10点钟结束了。</p>
<p>又变回熟悉的味道，明天继续努力！</p>
<p>不过文章还是要写。不管怎么样，把自己订下的目标做完了。</p>
<p>今天还是有那么一点点进步的，做了总比不做要强。</p>
 <a id="more"></a> 
<h1 id="时间不太快"><a href="#时间不太快" class="headerlink" title="时间不太快"></a>时间不太快</h1><p>其实，我一直觉得自己是很奇特的一个人。</p>
<p>思维僵硬，但是做事情又可以靠机械性重复把事情办好。</p>
<p>我认为在我脑海里，思考这东西是不存在的。看书只想着快点把书过一遍，然后宣称自己看过。但是说说自己看了点什么的时候，却发现自己什么也说不出来。在高中的时候，很多知识点不懂，我不是想着花时间去弄懂，习惯把它们堆在一起，最后它们成为了我无解的难题。在生活里面，可以很快的接受别人的观点，认为他们说的对啊，是这个道理呀。</p>
<p>思考是对世界的探索，是对未知的好奇。</p>
<p>我想我对于思考的缺失，源于自己的小时候。我很早就养成了偷懒的习惯，永远在最后一刻做自己的作业，为此不惜熬夜。思考一件事情的时候，感觉太过费脑子，就想着放下了。即使到现在，我还是懒得思考。看书的时候，就没有认认真真的思考过。我看过七八遍《如何阅读一本书》，是因为我从这本书上看到了如何才能算真正的读过书，有所收获。</p>
<p>但是到现在，我发现我还是在原地踏步。书是一本又一本在读，但是留在心里的东西却没有多少。</p>
<p>在现在这个点，经历了很多空虚、寂寞的时间。我明白到，其实是我的心在作祟。我太过于浮躁，太过于求成，巴不得一天看完两本书，第二天就融会贯通。结果就是，书翻完了，人却没有收获。</p>
<p>与此同时，陪伴我这种心态的，还有各种各样的时间被浪费在直播、游戏之中。眼一睁、眼一闭，时间就过去了，然后晚上懊悔地说，今天又浪费了，明天一定好好干。</p>
<p>时间不是过的太快，而是自己的心不对。</p>
<h1 id="控制自己的想法"><a href="#控制自己的想法" class="headerlink" title="控制自己的想法"></a>控制自己的想法</h1><p>以前和一个博士姐姐聊过一个话题，如何看待把时间花费在游戏上，过后又觉得很后悔的行为？</p>
<p>她的回答是：这是一个很正常的事情。在即时快乐和延迟满足里面，选择谁都不是问题，谁都可以接受。</p>
<p>现在有点后悔，当时没有把这个话题进一步深入。当时觉得说的挺有道理的，既然玩了，就要享受玩的快乐，然后就一直在玩。</p>
<p>我又有一点点新的体会。因为我把大把的时间放在玩上，有点把自己玩废了的感觉。以至于现在每天回寝室，都是满怀罪恶感，感觉一天又这么被自己浪费了。</p>
<p>现在为什么会有这样的感觉，因为很多压力摆在面前。要毕业，要工作，要挣钱……但是自己现在却一无所长，有种废物既视感。</p>
<p>但每天确实是控制不住自己，每次工作之后，阶段性休息的时候，总想着直播或者游戏放松一下，但是放松之后，整个人状态都不对了，根本回不去工作状态。我意识到不能去这样放松，但是又始终控制不了自己的想法。</p>
<p>我是被自己那种安逸、偷懒、轻松想法控制住了。</p>
<p>我成为了自己的奴隶。</p>
<p>其实有计划，我是想做这样的人，但现实不是这样，我不应该这样被控制。</p>
<h1 id="行动"><a href="#行动" class="headerlink" title="行动"></a>行动</h1><p>我现在在尝试每天让自己多工作一点。</p>
<p>每天的基本任务是：200分钟编程练习、90分钟的阅读、30分钟的阅读总结、60分钟的写作。</p>
<p>但我发现很多时候，只能做一下200分钟的编程练习。</p>
<p>做完这之后，心态就产生了变化。从我干了这么久，应该休息一会了；到看完这部分，马上去工作；再到再看一集，再去工作；最后变成了今天已经没有时间了，明天再多花时间努力吧。</p>
<p>每天就是在这样的环境下重复，我也觉得很头疼。</p>
<p>现在有个新点子，用forest软件来计时，一旦开始计时，坚决不能把时间投入到有的没的上面。效果还行，但最怕的就是连计时也不想打开。</p>
<p>当然，这里面还有其他的问题，就是每天我九点到实验室，中午11点吃饭，然后吃完饭要午睡一个多小时，午睡完还要挂机划水找找状态，很多时间都是在这样的过程中被浪费了。</p>
<p>今天算是第一天把基本任务做完了，代价有点大。白天猛玩，晚上加班到10点。</p>
<p>其实不应该这一，380分钟，就是6小时工作量，应该白天坚决完成的，晚上得把时间用在科研上。</p>
<p>我觉得我可能应该去接受社会的毒打，在学校里面过的太过于安逸了。</p>
<p>应该采取不一样的行动！</p>
<p>早上6点50的闹钟，7点起床，7点40到实验室工作到11点。</p>
<p>11点–11点半吃饭，工作半小时</p>
<p>12点–13点半睡觉休息。</p>
<p>13点半-17点：工作</p>
<p>17点–18点： 吃饭</p>
<p>18点–22点，努力科研。</p>
<p>其实我超想要这样的状态，但是就是忍不住，写下这个表，监督自己吧。</p>
<p>做一个自己的掌控者。</p>
]]></content>
      <tags>
        <tag>myself</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode第4题</title>
    <url>/2019/11/28/leetcode%E7%AC%AC4%E9%A2%98/</url>
    <content><![CDATA[<h1 id="leetcode第4题"><a href="#leetcode第4题" class="headerlink" title="leetcode第4题"></a>leetcode第4题</h1> <a id="more"></a> 
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。</p>
<p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p>
<p>你可以假设 nums1 和 nums2 不会同时为空。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>示例1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line"></span><br><span class="line">则中位数是 2.0</span><br></pre></td></tr></table></figure>
<p>示例2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line"></span><br><span class="line">则中位数是 (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这道题真的是一点思路都没有啊（虽然我之前做过，说明白做了）。</p>
<p>我直接去找题解了，看题解也看了好一会。</p>
<p>题目要求是求两个有序数组的中位数。</p>
<p>我们分别有长度为m的数组A和长度为n的数组B。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A[0],A[1],...,A[m]</span><br><span class="line">B[0],B[1],...,B[n]</span><br></pre></td></tr></table></figure>
<p>思路在于把两个数组切分成两部分，并保证左边部分的数据小于右边部分的数据，且左右两块大小一致。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">left_part               |    right_part</span><br><span class="line">A[0],A[1],...,A[i-1]    |    A[i],...,A[m-1]</span><br><span class="line">B[0],B[1],...,B[J-1]    |    B[J],...,B[n-1]</span><br></pre></td></tr></table></figure>
<p>只要我们左边部分和右边部分大小一致，且A[i-1]&lt;B[j],B[j-1]&lt;A[i]，我们就找到了中位数（因为A和B是有序数组，A[i-1]&lt;A[i],B[j-1]&lt;B[j]先天成立）。</p>
<p>要保证上面提出的条件，我们有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i+j=(m+n-i-j)或i+j=(m+n+1-i-j)</span><br><span class="line">A[i-1]&lt;B[j]</span><br><span class="line">B[j-1]&lt;A[i]</span><br></pre></td></tr></table></figure>
<p>由此，我们得到了i和j的关系式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">j=(m+n)/2-i或j=(m+n+1)/2-i</span><br></pre></td></tr></table></figure>
<p>再分析i和j的位置(这里先不需要数组越界的情况，即i&gt;0且i&lt;m)：</p>
<p>如果A[i-1]&gt;B[j]，说明i偏大，应该减小i；</p>
<p>如果B[j-1]&gt;A[i]，说明j偏大，应该减小j，由于上面的式子，可以通过增大i，来减小j。</p>
<p>如果A[i-1]&lt;B[j]且B[j-1]&lt;A[i]，说明我们找对了位置，可以结束搜索，考虑输出。</p>
<p>接下来针对的是数组越界的情况，因为当i=0，j=0，i=m，j=n的时候，此时已经满足上述两个条件。由于数组会越界，程序出现错误，因此需要特殊处理。</p>
<p>当i=0时，左边部分只有数组B，左边最大为B[j-1]。</p>
<p>当j=0时，左边部分只有数组A，左边最大为A[i-1]。</p>
<p>如果没有越界，则左边最大为max(A[i-1],B[j-1])。</p>
<p>如果长度之和为奇数，可以直接输出左边最大，它就是我们的结果。</p>
<p>不然，统计右边最小，也分为越界和没有越界。</p>
<p>输出左边最大和右边最小和的二分之一。</p>
<p>至此，这道题就结束了，贴出解法。</p>
<h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; float:</span></span><br><span class="line">        m=len(nums1)</span><br><span class="line">        n=len(nums2)</span><br><span class="line">        <span class="keyword">if</span> m&gt;n:</span><br><span class="line">            m,n,nums1,nums2=n,m,nums2,nums1</span><br><span class="line"></span><br><span class="line">        imin=<span class="number">0</span></span><br><span class="line">        imax=m</span><br><span class="line">        <span class="keyword">if</span> (m+n)%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">            halfLen=(m+n+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            halfLen=(m+n)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> imin&lt;=imax:</span><br><span class="line">            i=(imin+imax)//<span class="number">2</span></span><br><span class="line">            j=(int)(halfLen-i)</span><br><span class="line">            <span class="keyword">if</span> i&lt;m <span class="keyword">and</span> nums2[j<span class="number">-1</span>]&gt;nums1[i]:</span><br><span class="line">                imin=i+<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums1[i<span class="number">-1</span>]&gt;nums2[j]:</span><br><span class="line">                imax=i<span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> i==<span class="number">0</span>:max_of_left=nums2[j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">elif</span> j==<span class="number">0</span>:max_of_left=nums1[i<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">else</span>:max_of_left=max(nums1[i<span class="number">-1</span>],nums2[j<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">if</span>(m+n)%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> max_of_left</span><br><span class="line">                <span class="keyword">if</span> i==m:min_of_right=nums2[j]</span><br><span class="line">                <span class="keyword">elif</span> j==n:min_of_right=nums1[i]</span><br><span class="line">                <span class="keyword">else</span>:min_of_right=min(nums1[i],nums2[j])</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> (max_of_left+min_of_right)/<span class="number">2</span></span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>中位数的问题，归根到底是一个数学问题，思路清晰了，结果就出来了。</p>
<p>学到了中位数问题，分成左右两部分的思想。</p>
<p>这里还有一个小细节。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (m+n)%2==1:</span><br><span class="line">    halfLen=(m+n+1)//2</span><br><span class="line">else:</span><br><span class="line">    halfLen=(m+n)//2</span><br></pre></td></tr></table></figure>
<p>这是我的取一半，但实际上题解里的取一半是不一样的，如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">halfLen=(m+n+1)//2</span><br></pre></td></tr></table></figure>
<p>思考了一会，发现确实有道理，如果是奇数，则+1才是真正的一半；如果是偶数，+1也不会影响结果。</p>
<p>还是很弱啊，这道题虽然是个困难题，但其实我做过蛮多遍了，没有复习，结果就等于前面的都白给了。</p>
<p>加油呗！</p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode第3题</title>
    <url>/2019/11/27/leetcode%E7%AC%AC3%E9%A2%98/</url>
    <content><![CDATA[<h1 id="leetcode第3题"><a href="#leetcode第3题" class="headerlink" title="leetcode第3题"></a>leetcode第3题</h1> <a id="more"></a> 
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p> 给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。 </p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>示例1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>
<p>示例2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>
<p>示例3<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是子串的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>一开始做，就只想到双重循环，对每一个点进行一次判断，每个点有几个不重复的字符串。最后给出最大的结果。</p>
<p>结果就是效率好低啊，给出我的解法1。</p>
<p>然后我就去找了提交记录里面最快的一个方法学习了一下。</p>
<p>他的特点在于只用了一次循环，就解决了这个问题，大大地提高了运行效率，解法贴在解法2里面。</p>
<p>关键点在于利用字符串的特性，每次找到重复字符后，从保存的重复字符串中抽取字符，组成新的结果，重新进行比较。</p>
<p>我试着改一改我的解法1。</p>
<p>效率快了很多，但还是没有解法2效率高，我认为差距在于我的列表操作时间比不上字符串操作，low了一点，但也把解法3贴出来吧。</p>
<h1 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        d=[]</span><br><span class="line">        maxcount=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            count=<span class="number">1</span></span><br><span class="line">            d=[]</span><br><span class="line">            d.append(s[i])</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(s)):</span><br><span class="line">                <span class="keyword">if</span> s[j] <span class="keyword">in</span> d:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                count=count+<span class="number">1</span></span><br><span class="line">                d.append(s[j])</span><br><span class="line">            <span class="keyword">if</span> count&gt;maxcount:</span><br><span class="line">                maxcount=count</span><br><span class="line">        <span class="keyword">return</span> maxcount</span><br></pre></td></tr></table></figure>
<h1 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> s:</span><br><span class="line">            res=<span class="string">''</span></span><br><span class="line">            slen=<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> meb <span class="keyword">in</span> s:</span><br><span class="line">                <span class="keyword">if</span> meb <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">                    res+=meb</span><br><span class="line">                    <span class="keyword">if</span> len(res)&gt;slen:</span><br><span class="line">                        slen=len(res)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    i=res.find(meb)</span><br><span class="line">                    res=res[i+<span class="number">1</span>:]+meb</span><br><span class="line">            <span class="keyword">return</span> slen</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h1 id="解法3"><a href="#解法3" class="headerlink" title="解法3"></a>解法3</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        d=[]</span><br><span class="line">        maxcount=<span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> s:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                    d.append(i)</span><br><span class="line">                    <span class="keyword">if</span> maxcount&lt;len(d):</span><br><span class="line">                        maxcount=len(d)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    index=d.index(i)</span><br><span class="line">                    d=d[index+<span class="number">1</span>:]</span><br><span class="line">                    d.append(i)</span><br><span class="line">            <span class="keyword">return</span> maxcount</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>学到了思路，对于重复字符比较问题，可以把重复字符暂存起来。</p>
<p>不需要两次循环，只需要在重复的时候，把暂存的字符串更新一下，能给下次使用就可以了。</p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode第2题</title>
    <url>/2019/11/26/leetcode%E7%AC%AC2%E9%A2%98/</url>
    <content><![CDATA[<h1 id="leetcode第2题"><a href="#leetcode第2题" class="headerlink" title="leetcode第2题"></a>leetcode第2题</h1> <a id="more"></a> 
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>很早就写过这道题，但是这次写又遇到很多的问题(我真是菜啊)，就写一写思路吧。</p>
<p>首先考虑两个链表是空的情况。单个空，则直接返回另外一个。</p>
<p>然后设置节点，这里有一个问题，就是为什么要有一个头节点，我到现在，还没搞清楚。就是没有头节点，答案就是不正确。</p>
<p>我本来想着是一直加下去处理情况，然后直接把另外的剩下部分挂上去，直接返回结果，但是出了很多问题，就先把记忆里的解法1，先倒腾出来了。</p>
<p>最后要考虑的是，退出循环后，还有一个进位需要处理。</p>
<p>然后，就返回头节点的后面部分，这里也存在一个疑惑。</p>
<p>我试着写一写我的解法2。</p>
<h1 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">if</span> l2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        carry=<span class="number">0</span></span><br><span class="line">        sum=<span class="number">0</span></span><br><span class="line">        head=ListNode(<span class="number">0</span>)</span><br><span class="line">        result=head</span><br><span class="line">        <span class="keyword">while</span>(l1 <span class="keyword">or</span> l2):</span><br><span class="line">            sum=<span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> l1!=<span class="literal">None</span>:</span><br><span class="line">                sum+=l1.val</span><br><span class="line">                l1=l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                sum+=<span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> l2!=<span class="literal">None</span>:</span><br><span class="line">                sum+=l2.val</span><br><span class="line">                l2=l2.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                sum+=<span class="number">0</span></span><br><span class="line">            sum+=carry</span><br><span class="line">            result.next=ListNode(sum%<span class="number">10</span>)</span><br><span class="line">            result=result.next</span><br><span class="line">            carry=sum//<span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> carry==<span class="number">1</span>:</span><br><span class="line">            result.next=ListNode(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure>
<h1 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">if</span> l2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        carry=<span class="number">0</span></span><br><span class="line">        sum=<span class="number">0</span></span><br><span class="line">        head=ListNode(<span class="number">0</span>)</span><br><span class="line">        result=head</span><br><span class="line">        <span class="keyword">while</span>(l1 <span class="keyword">or</span> l2):</span><br><span class="line">            sum=l1.val+l2.val+carry</span><br><span class="line">            result.next=ListNode(sum%<span class="number">10</span>)</span><br><span class="line">            result=result.next</span><br><span class="line">            carry=sum//<span class="number">10</span></span><br><span class="line">            l1=l1.next</span><br><span class="line">            l2=l2.next</span><br><span class="line">            <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">while</span>(l2):</span><br><span class="line">                    sum=l2.val+carry</span><br><span class="line">                    result.next=ListNode(sum%<span class="number">10</span>)</span><br><span class="line">                    result=result.next</span><br><span class="line">                    carry=sum//<span class="number">10</span></span><br><span class="line">                    l2=l2.next</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> l2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">while</span>(l1):</span><br><span class="line">                    sum=l1.val+carry</span><br><span class="line">                    result.next=ListNode(sum%<span class="number">10</span>)</span><br><span class="line">                    result=result.next</span><br><span class="line">                    carry=sum//<span class="number">10</span></span><br><span class="line">                    l1=l1.next</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> carry==<span class="number">1</span>:</span><br><span class="line">            result.next=ListNode(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure>
<p>解法2和解法1时间复杂度一致，感觉效率一样，提交时间有点看运气呀。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">执行用时 :68 ms, 在所有 python3 提交中击败了99.26%的用户</span><br><span class="line"></span><br><span class="line">内存消耗 :14 MB, 在所有 python3 提交中击败了5.06%的用户</span><br></pre></td></tr></table></figure>
<p>我这个看起来麻烦好多啊，但总归我自己写的，贴上来骄傲一下！</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>发现，温故而知新的重要性。</p>
<p>很多知识当时觉得自己会了，过几天回过头又不会了，真的尴尬啊。</p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔之2019-11-25</title>
    <url>/2019/11/25/%E9%9A%8F%E7%AC%94%E4%B9%8B2019-11-25/</url>
    <content><![CDATA[<h1 id="梦想"><a href="#梦想" class="headerlink" title="梦想"></a>梦想</h1><p>一直很崇拜王阳明，也一直想做一个像他这样的人。在我印象里，有一个词语叫做，内圣外王，它可以用来形容这样的人。于我来说，要培养这样的心灵和品德。作为结果，日常生活中不会浪费时间；即使浪费了时间，也应该及时反审自身，重新走上正轨；只要朝着既定目标前进，就不会出现对未来的焦虑和忧愁。</p>
 <a id="more"></a> 
<h1 id="现实"><a href="#现实" class="headerlink" title="现实"></a>现实</h1><p>现实就是很残酷，虽然喜欢王阳明，但是他的传习录一直摆在边上，不太肯花时间来细品，总会找各种有的没的理由。结果就是只听过人生的只言片语，但是却没有跟他真正在心灵上对话过。</p>
<p>生活里，定下了很多目标，结果就是执行了一段时间就放弃了。行百里者半九十，说的是快成功时放弃了；对我来说，刚走出一点点，就不自觉地忘记了当初立下的豪言壮语，就和我放弃了运动、冥想、写文章一样，这样的事情真的太多了。我本来可以有更多收获的。</p>
<p>每天各种各样的时间，都沉迷在小说、直播中。而且一开始，少则两三个小时，多则就是一整天。</p>
<p>现在是晚上九点半，到这个点，心里不自觉的想要放松，可以明天再来抓紧时间，明天重新开始。可是，一日复一日，每天都是这个样子。</p>
<p>今天本来的想法是编程训练四小时、阅读一个半小时、总结半小时、随笔一小时。完成的结果，应当是编程训练四小时、阅读半小时、随笔一小时。为什么会这样，因为在工作之后，不自觉的就想着我可以休息一下，放松一下，结果就是数个小时、悄悄地划走。今天，我本来可以更好。</p>
<h1 id="戾气"><a href="#戾气" class="headerlink" title="戾气"></a>戾气</h1><p>这几天，一直感觉自己戾气很重，不知道我身边的人有没有感受到。</p>
<p>在写这个的时候，问了实验室的其他人，他们说我没有给他们这个感觉。</p>
<p>其实，我感觉自己戾气真的很重，但是因为可能发脾气，会影响到同学之间的关系，又会被人说矫情，就一直藏在心里。</p>
<p>我的实验室玩游戏其实很普遍，大多数人玩游戏，开黑语音啥的，我都可以接受。有个师兄语音说方言，给我的感觉就是很难受，普通话还可以接受，但是方言夹在一起，我就感觉很接受不了，主要是由于说话的语调。其实，我想说，玩游戏就玩游戏，为什么要叫唤呢？人没有13数吗？我玩游戏的时候就不太说话，静静地玩游戏，不好吗？</p>
<p>同一个师兄，最近他成为了预备党员，然后学校的预备党员各种活动，包括他都各种吐槽，嫌这嫌那，说学校的事情真的麻烦。最近预备党员要结业考试了，他想着是回家时间和这个冲突，害的自己回不了家，然后一顿吐槽。然后，他对党的一些看法，认为现在的一些做法就是形式主义。我也接受不了。我想的是，既然这么看不起，当初为什么要入党，做一个围观群众不好吗？</p>
<p>我不知道是不是我自己先入为主，就一直有意见。但是我也不想说，因为说真话是会伤感情的，想着是快毕业了，大家好聚好散，因为别人的想法，我改变不了，我也只能尽量地从自身做起，小心翼翼地维护关系。</p>
<p>不知道这是不是和我自己的小心思、小气魄有关。我觉得这些本来不应该成为问题，毕竟和我自身无关，我要做的是首先做好自己。</p>
<h1 id="有关生性凉薄"><a href="#有关生性凉薄" class="headerlink" title="有关生性凉薄"></a>有关生性凉薄</h1><p>今天突然在知乎看到了这个名词，就觉得这个词语和我自身很贴切。</p>
<p>以下这段话，复制于知乎，我觉得很有道理。</p>
<p>我觉得我就是一个凉薄的人，外热内冷。和别人交往时大大咧咧，也能聊到一起，但事实我内心没有一点波动。有人伤心了，受伤了，我冲上去关心他，但事实上我内心没有一点担忧；我看上去嘘寒问暖，内心其实无感甚至有点不耐烦。我参加同学聚会、宿舍聚会，只是不想显得不合群，其实我一点都不想参加。</p>
<p>我的状态，借用另一个答主的回答：</p>
<p>对各种感情都不会深入，包括亲情都很淡，仅仅维持在不违反社会道德底线之上，基本都是表面上的礼节。</p>
<p>我不是排斥一群人的狂欢，但更享受一个人的孤独。</p>
<p>我一个人吃饭，不用吃前拍照，吃一半又拍照，吃完还拍照，还要P图发朋友圈。我喜欢一个人吃烧烤、火锅，也不在乎其他人异样的眼光。</p>
<p>我一个人上课，下课。我不想明明想坐第一排，却要跟随大流坐后面。</p>
<p>我一个人在图书馆写作业看书，不和舍友一起刷剧、打游戏。</p>
<p>我一个人逛街，喜欢那种无目的地的乱逛，喜欢那种不经意发现喜欢之物的惊喜感。</p>
<p>我一个人看电影，选择自己喜欢的恐怖、惊悚、文艺主题，也不在乎自己一个人处于小情侣、朋友团里。</p>
<p>我从来不觉得我是一个另类、一个怪物，不同的人有不同的选择而已。</p>
<p>我觉得，我的很多状态，都在这段描述里面，很多时候，我只是不想显得太过不合群，我的内心更加的享受一个人的时候。</p>
<p>我只是在生活中不懂得拒绝，不懂得特立独行。</p>
<h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><p>我特现实，又很不现实。</p>
<p>我特现实，就在于一直想赚钱，想追求财务自由。</p>
<p>我又很不现实，我浪费了很多时间，错过了很多机会，没有努力，错过好几千的奖学金；没有努力，所以到现实，还是在花父母的钱，还在看父母辛苦劳作；没有努力，每天都想着明天会更好。但是不行动，一直在原地打转，却幻想从天而降的馅饼。</p>
<p>我其实超想当个公务员，首先是为自己，其次是为国家。但我又觉得自己考不上，又不太想花时间去准备。明年这个时候，应该不会去报名，因为没有行动。</p>
<p>现在在做的就是，努力当个JAVA开发，在赚钱的路上踏出自己的第一步。</p>
<p>这次应该没有半途放弃的哀嚎，我是认真的。</p>
]]></content>
      <tags>
        <tag>myself</tag>
      </tags>
  </entry>
  <entry>
    <title>敦盛</title>
    <url>/2019/11/25/%E6%95%A6%E7%9B%9B/</url>
    <content><![CDATA[<center><font size="8">敦盛</font></center>

 <a id="more"></a> 
<p>常思人世漂流无常，譬如朝露，水中映月 。</p>
<p>刹那繁华瞬间即逝，风流人物，今非昔比。</p>
<p>人生五十年，莫非熙熙攘攘，浮生幻梦。</p>
<p>名垂青史，功败湮灭，只是宿命因果 。</p>
<p>一念之间，有何可惜，急至京都忧心难忍。</p>
<p>狱门示众，敦盛之首，窃而归家传僧供奉。</p>
<p>叹息如烟，人间无常，人生五十年。</p>
<p>莫非熙熙攘攘，浮生幻梦。</p>
]]></content>
      <tags>
        <tag>古典</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode第1题</title>
    <url>/2019/11/25/leetcode%E7%AC%AC1%E9%A2%98/</url>
    <content><![CDATA[<h1 id="leetcode第1题"><a href="#leetcode第1题" class="headerlink" title="leetcode第1题"></a>leetcode第1题</h1> <a id="more"></a> 
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>很早就写过这道题，就一直有印象，就和单词书的abandon一样，始终是第一页的第一个单词，从开始到放弃，一直在这个地方徘徊。</p>
<p>题目也很简单，最简单的做法就是双重循环暴力破解，但是时间复杂度为O(n^2),结果就是超时了，不太行。</p>
<p>所以要用更加高级的做法，用空间换时间，引出了哈希的概念。</p>
<p>把用过的数据放在hash中，因为查询哈希只需要O(1)的时间,再加一次循环，解答本题的时间复杂度为O(n)，问题就解决了。</p>
<p>在python里面，哈希就是字典，更加简单容易。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在进行的时候，忘记了python遍历索引和值，卡了好一会，在网上搜索到了enumerate函数，解决了这个问题。</p>
<p>我又试着不用enumerate来解决这个问题。</p>
<p>下面给出了我的两个解法。</p>
<h2 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        d=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> target-v <span class="keyword">in</span> d:</span><br><span class="line">                <span class="keyword">return</span> d[target-v],k</span><br><span class="line">            d[v]=k</span><br></pre></td></tr></table></figure>
<h2 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        d=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> target-nums[i] <span class="keyword">in</span> d:</span><br><span class="line">                <span class="keyword">return</span> d[target-nums[i]],i</span><br><span class="line">            d[nums[i]]=i</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>就时间上来讲，enumerate的做法比我快很多，不知道差距在哪里？</p>
<p>猜测应该是实现方式的差距，我调用了range，它的效率可能不高。</p>
<p>这个问题留给以后解决吧！</p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>新的开始</title>
    <url>/2019/11/25/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/</url>
    <content><![CDATA[<p> 时隔八个月，我开始写我的个人博客，希望这次不要放弃吧。 </p>
 <a id="more"></a> 
<p>话说，新的开始把以前的东西给删了，结果删的时候又出问题了，我可真是个小白呀。</p>
]]></content>
      <tags>
        <tag>myself</tag>
      </tags>
  </entry>
</search>
